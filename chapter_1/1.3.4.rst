1.3.4 値として返される手続き
==========================================

==========================================
Q. 手続きを引数として渡せるようになると何が嬉しいの？
==========================================

「表現力が得られる」と言われた所でいまいちピンとこない.
そこで色々と検証した結果, 関数を引数として渡す事に関する具体的なメリットについて, 例えば以下のようなケースでの抽象化を楽にしてくれることがわかった.

.. sourcecode:: scheme

  (define hoge
    ; 共通処理
    ; 異なる処理
    ; 共通処理
  )

==========================================
Q. でも, 別に関数を渡さなくたって, やろうと思えば値を渡す形でも上のことは実現できるよね.
==========================================

例えば以下のような関数を考えてみる.

.. sourcecode:: scheme

  (define (hoge f)
    (lambda (x)
      (if (= x 0)
        1
        (average x (f x)))))

これをlambdaを使わずにやろうとすると...

パターン1: 

.. sourcecode:: scheme

  (define (hoge x y) ; y は f(x) の計算結果
    (if (= x 0)
      1
      (average x y)))

できないことはないみたいだ. ただこういう実装の場合,
lambdaでいう所の↓みたいな処理を書きたい場合とかに困る.

.. sourcecode:: scheme

  (define (foo f)
    (lambda (x)
      (if (= x 0)
      (another-function (f x) (average x (f x)))))

パターン2: 

.. sourcecode:: scheme

  (define (f a) (特定の処理) )
  (define (hoge x)
    (if (= x 0)
      1
      (average x (f x))))

要するにパターン2では関数fを固定しているわけだが, そうすると今度は再利用性の観点で全く融通が利かなくなる.　　
上記は一例だが, 値で渡そうとするとこの他にも色々な制約が出てきそうなので, lambdaを使うことでそういう諸々の制約から解き放たれることが挙げられるのではないかなと思う.

================================================
Newton法
================================================

まず, square-root が Newton’s method(ニュートン法) の「特別な場合」ということに関して.　　
これまで1章において様々な抽象を扱ってきたが, ある概念の「特別な場合」というのは, 抽象化された概念が特定のシーンにおいて具体的な値を持っている状況ととらえるとわかりやすい.
こう考えると, Newton's method の「特別な場合」について語られているということはその「特別な場合」を包含しうる抽象が存在するということが理解できる. そしてその抽象化されたNewton's methodこそまさに本文中に出ている

f(x) = x - g(x) / Dg(x)

という式にあたる. 順を追ってそれぞれの項を見ていくと, 以下の形で説明できる.

・**x** は 計算処理の際に渡す実際の値.  

・**g(x)** は xに任意の関数処理を適用したもの.　　
例えば数値を立方する関数 cube x. すなわち x |-> x^3 となり,　　
例えばx = 5が渡されたら 5^3 = 125 が返る.

・**Dg(x)** はg(x)を微分したもの.　　
上の例で言うと、cube x の微分. すなわち x |-> 3x^2 となり,　　
例えばx = 5が渡されたら 3 * 5^2 = 75 が返る.

最終的に上記の式で何が言いたいかというと **ｇ(x) = 0 の答えは 上述の関数 f(x) の不動点と一緒になりますよ**, ということである.  
だから, 例えば g(x) = 0 が三次方程式などの場合にその答えを求めたい場合は, 関数f(x) の不動点を求めればよいということになる.

なお, 上記の f(x) を手続きに落としたものが本文中の newton-transform であるが, これはf(x)の左辺と右辺の値の誤差を修正する必要がある( xについては判明しているが, f(x) はまだ未知の数値で, これまで我々は予測値を立てていたことを思い出してほしい )ため, そのままでは使えない. すなわち, 以前学習した不動点処理の関数 fixed-point を適用する必要がある. この fixed-point の適用になってニュートン法を使用した計算をできるようにしたものが newtons-method 手続きである.

================================================
抽象と第一級手続き
================================================

第一級要素について
・変数として名前がつけられる。　　
・手続きに引数として渡せる。　　
・手続きの結果として返される。　　
・データ構造に組み込める。

Lispは手続きにこの第一級要素の特性を持たせたため, 制約を受けずに自由度の高い抽象の構築を行うことができる.